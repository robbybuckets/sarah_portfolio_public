{"ast":null,"code":"/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License. *\n */\n\n/**\n * balancetext.js\n *\n * Author: Randy Edmunds\n */\n\n/* global define, module */\n\n/*\n * Copyright (c) 2007-2009 unscriptable.com and John M. Hann\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the name(s) of the above\n * copyright holders (unscriptable.com and John M. Hann) shall not be\n * used in advertising or otherwise to promote the sale, use or other\n * dealings in this Software without prior written authorization.\n *\n * http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/\n *\n * Tested to work on (lowest browser):\n * - Sarari 4\n * - Chrome 16\n * - Firefox 10\n * - IE 9\n * - Edge 13\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.balanceText = factory();\n  }\n})(this, function () {\n  /**\n   * Line breaking global vars\n   */\n  var breakMatches, wsnwMatches, wsnwOffset;\n  /**\n   * Selectors and elements to watch;\n   * calling $.balanceText(elements) adds \"elements\" to this list.\n   */\n\n  var watching = {\n    sel: [],\n    // default class to watch\n    el: []\n  };\n  /**\n   * Have handlers been initialized?\n   */\n\n  var handlersInitialized = false;\n  /**\n   * Is this a polyfill?\n   */\n\n  var polyfilled = false;\n  /**\n   * Do nothing\n   */\n\n  function noop() {}\n  /**\n   * Loop that works with array-likes\n   * @param {Array-like} elements - List of elements to run a function on\n   * @param {Function}   callback - The function to call on each supplied element\n   */\n\n\n  function forEach(elements, callback) {\n    Array.prototype.forEach.call(elements, callback);\n  }\n  /**\n   * Polyfill for $(document).ready()\n   *\n   * @param {Function} fn - The function to execute when the document is ready\n   */\n\n\n  function ready(fn) {\n    if (document.readyState !== \"loading\") {\n      fn();\n    } else if (document.addEventListener) {\n      document.addEventListener(\"DOMContentLoaded\", fn);\n    } else {\n      document.attachEvent(\"onreadystatechange\", function () {\n        if (document.readyState !== \"loading\") {\n          fn();\n        }\n      });\n    }\n  }\n  /**\n   * Debounces a function over a threshold\n   *\n   * @param {Function} func      - The function to debounce\n   * @param {number}   threshold - time in ms\n   * @param {boolean}  execAsap  - when true, execute immediately\n   * @param args\n   * @return {Function} Debounced function\n   */\n\n\n  function debounce(func, threshold, execAsap) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n\n    var timeout;\n    return function () {\n      var obj = this;\n\n      function delayed() {\n        if (!execAsap) {\n          func.apply(obj, args);\n        }\n\n        timeout = null;\n      }\n\n      if (timeout) {\n        clearTimeout(timeout);\n      } else if (execAsap) {\n        func.apply(obj, args);\n      }\n\n      timeout = setTimeout(delayed, threshold || 100);\n    };\n  }\n  /**\n   * Determine whether the document supports TextWrap\n   * @return {boolean}\n   */\n\n\n  function hasTextWrap() {\n    if (typeof window === \"undefined\") {\n      return false;\n    }\n\n    var style = document.documentElement.style;\n    return style.textWrap || style.WebkitTextWrap || style.MozTextWrap || style.MsTextWrap;\n  }\n  /**\n   * Object for tracking next whitespace params\n   */\n  // eslint-disable-next-line camelcase\n\n\n  function NextWS_params() {\n    this.reset();\n  }\n\n  NextWS_params.prototype.reset = function () {\n    this.index = 0;\n    this.width = 0;\n  };\n  /**\n   * Check if index is contained in previously calculated list of white-space:nowrap ranges\n   *\n   * @param {number} index - the index of the character to check\n   * @return {boolean}\n   */\n\n\n  function isWhiteSpaceNoWrap(index) {\n    // Is index inside 1 of the ranges?\n    // start and end are breakable, but not inside range\n    return wsnwMatches.some(function (range) {\n      return range.start < index && index < range.end;\n    });\n  }\n  /**\n   * Recursively calculate white-space:nowrap offsets for line.\n   *\n   * @param {Node}    el         - the element to act on\n   * @param {boolean} includeTag - include length of tag itself\n   */\n\n\n  function recursiveCalcNoWrapOffsetsForLine(el, includeTag) {\n    if (el.nodeType === el.ELEMENT_NODE) {\n      // Found an embedded tag\n      var style = window.getComputedStyle(el);\n\n      if (style.whiteSpace === \"nowrap\") {\n        // Tag with white-space:nowrap - add match, skip children\n        var len = el.outerHTML.length;\n        wsnwMatches.push({\n          start: wsnwOffset,\n          end: wsnwOffset + len\n        });\n        wsnwOffset += len;\n      } else {\n        // Tag without white-space:nowrap - recursively check children of tag\n        forEach(el.childNodes, function (child) {\n          recursiveCalcNoWrapOffsetsForLine(child, true);\n        });\n\n        if (includeTag) {\n          // Length of opening tag, attributes, and closing tag\n          wsnwOffset += el.outerHTML.length - el.innerHTML.length;\n        }\n      }\n    } else if (el.nodeType === el.COMMENT_NODE) {\n      wsnwOffset += el.length + 7; // delimiter: <!-- -->\n    } else if (el.nodeType === el.PROCESSING_INSTRUCTION_NODE) {\n      wsnwOffset += el.length + 2; // delimiter: < >\n    } else {\n      // Text node: add length\n      wsnwOffset += el.length;\n    }\n  }\n  /**\n   * Calculate white-space:nowrap offsets for line.\n   *\n   * @param {Node}    el             - the element to act on\n   * @param {string}  oldWS          - \"old\" whitespace setting for temporarily resetting\n   * @param {number}  lineCharOffset - char offset of current line from start of text\n   */\n\n\n  function calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset) {\n    // For first line (lineCharOffset === 0), calculate start and end offsets for each\n    // white-space:nowrap element in the line.\n    if (lineCharOffset === 0) {\n      // Reset whiteSpace setting when breakMatches is being calculated\n      // so white-space:nowrap can be detected in text\n      el.style.whiteSpace = oldWS;\n      wsnwOffset = 0;\n      wsnwMatches = [];\n      recursiveCalcNoWrapOffsetsForLine(el, false); // Restore temporary whitespace setting to recalc width\n\n      el.style.whiteSpace = \"nowrap\";\n    } else {\n      // For all other lines, update the offsets for current line\n      // 1. Ignore matches less than offset\n      // 2. Subtract offset from remaining matches\n      var newMatches = [];\n      wsnwMatches.forEach(function (match) {\n        if (match.start > lineCharOffset) {\n          newMatches.push({\n            start: match.start - lineCharOffset,\n            end: match.end - lineCharOffset\n          });\n        }\n      });\n      wsnwMatches = newMatches;\n    }\n  }\n  /**\n   * Strip balance-text tags from an element inserted in previous run\n   *\n   * @param {Node} el - the element to act on\n   */\n\n\n  function removeTags(el) {\n    // Remove soft-hyphen breaks\n    var brs = el.querySelectorAll('br[data-owner=\"balance-text-hyphen\"]');\n    forEach(brs, function (br) {\n      br.outerHTML = \"\";\n    }); // Replace other breaks with whitespace\n\n    brs = el.querySelectorAll('br[data-owner=\"balance-text\"]');\n    forEach(brs, function (br) {\n      br.outerHTML = \" \";\n    }); // Restore hyphens inserted for soft-hyphens\n\n    var spans = el.querySelectorAll('span[data-owner=\"balance-text-softhyphen\"]');\n\n    if (spans.length > 0) {\n      forEach(spans, function (span) {\n        var textNode = document.createTextNode(\"\\xAD\");\n        span.parentNode.insertBefore(textNode, span);\n        span.parentNode.removeChild(span);\n      });\n    } // Remove spans inserted for justified text\n\n\n    spans = el.querySelectorAll('span[data-owner=\"balance-text-justify\"]');\n\n    if (spans.length > 0) {\n      var txt = \"\";\n      forEach(spans, function (span) {\n        txt += span.textContent;\n        span.parentNode.removeChild(span);\n      });\n      el.innerHTML = txt;\n    }\n  }\n  /**\n   * Checks to see if we should justify the balanced text with the\n   * element based on the textAlign property in the computed CSS\n   *\n   * @param {Node} el - element to check\n   * @return {boolean}\n   */\n\n\n  var isJustified = function isJustified(el) {\n    var style = el.currentStyle || window.getComputedStyle(el, null);\n    return style.textAlign === \"justify\";\n  };\n  /**\n   * Add whitespace after words in text to justify the string to\n   * the specified size.\n   * @param {Node}    el       - the element to justify\n   * @param {string}  txt      - text string\n   * @param {number}  conWidth - container width\n   * @return {string} Justified text\n   */\n\n\n  function justify(el, txt, conWidth) {\n    txt = txt.trim();\n    var words = txt.split(\" \").length;\n    txt = \"\".concat(txt, \" \"); // if we don't have at least 2 words, no need to justify.\n\n    if (words < 2) {\n      return txt;\n    } // Find width of text in the DOM\n\n\n    var tmp = document.createElement(\"span\");\n    tmp.innerHTML = txt;\n    el.appendChild(tmp);\n    var size = tmp.offsetWidth;\n    tmp.parentNode.removeChild(tmp); // Figure out our word spacing and return the element\n\n    var wordSpacing = Math.floor((conWidth - size) / (words - 1));\n    tmp.style.wordSpacing = \"\".concat(wordSpacing, \"px\");\n    tmp.setAttribute(\"data-owner\", \"balance-text-justify\");\n    var div = document.createElement(\"div\");\n    div.appendChild(tmp);\n    return div.innerHTML;\n  }\n  /**\n   * Returns true iff char at index is a break char outside of HTML < > tags.\n   * Break char can be: whitespace (except non-breaking-space: u00a0),\n   * hypen, emdash (u2014), endash (u2013), or soft-hyphen (u00ad).\n   *\n   * @param {string} txt   - the text to check\n   * @param {number} index - the index of the character to check\n   * @return {boolean}\n   */\n\n\n  function isBreakChar(txt, index) {\n    var re = /([^\\S\\u00a0]|-|\\u2014|\\u2013|\\u00ad)(?![^<]*>)/g;\n    var match;\n\n    if (!breakMatches) {\n      // Only calc break matches once per line\n      breakMatches = [];\n      match = re.exec(txt);\n\n      while (match !== null) {\n        if (!isWhiteSpaceNoWrap(match.index)) {\n          breakMatches.push(match.index);\n        }\n\n        match = re.exec(txt);\n      }\n    }\n\n    return breakMatches.indexOf(index) !== -1;\n  }\n  /**\n   * In the current implementation, an index is a break\n   * opportunity in txt iff it is:\n   * - 0 or txt.length\n   * - index of a non-whitespace char immediately preceded by a\n   *   whitespace, hyphen, soft-hyphen, em-dash, or en-dash char.\n   *\n   * Thus, it doesn't honour \"white-space\" or any other Unicode\n   * line-breaking classes.)\n   *\n   * @precondition 0 <= index && index <= txt.length\n   *\n   * @param {string} txt   - the text to check\n   * @param {number} index - the index to check\n   * @return {boolean}\n   */\n\n\n  function isBreakOpportunity(txt, index) {\n    return index === 0 || index === txt.length || isBreakChar(txt, index - 1) && !isBreakChar(txt, index);\n  }\n  /**\n   * Finds the first break opportunity (@see isBreakOpportunity)\n   * in txt that's both after-or-equal-to index c in the direction dir\n   * and resulting in line width equal to or past clamp(desWidth,\n   * 0, conWidth) in direction dir.  Sets ret.index and ret.width\n   * to the corresponding index and line width (from the start of\n   * txt to ret.index).\n   *\n   * @param {Node}    el       - element\n   * @param {string}  txt      - text string\n   * @param {number}  conWidth - container width\n   * @param {number}  desWidth - desired width\n   * @param {number}  dir      - direction (-1 or +1)\n   * @param {number}  c        - char index (0 <= c && c <= txt.length)\n   * @param {Object}  ret      - return {index: {number}, width: {number}} of previous/next break\n   */\n\n\n  function findBreakOpportunity(el, txt, conWidth, desWidth, dir, c, ret) {\n    var w;\n\n    if (txt && typeof txt === \"string\") {\n      for (;;) {\n        while (!isBreakOpportunity(txt, c)) {\n          c += dir;\n        }\n\n        el.innerHTML = txt.substr(0, c);\n        w = el.offsetWidth;\n\n        if (dir < 0) {\n          if (w <= desWidth || w <= 0 || c === 0) {\n            break;\n          }\n        } else if (desWidth <= w || conWidth <= w || c === txt.length) {\n          break;\n        }\n\n        c += dir;\n      }\n    }\n\n    ret.index = c;\n    ret.width = w;\n  }\n  /**\n   * Detects the width of a non-breaking space character, given the height of\n   * the element with no-wrap applied.\n   *\n   * @param {Node}   el - element\n   * @param {number} h  - height\n   * @return {number}\n   */\n\n\n  function getSpaceWidth(el, h) {\n    var container = document.createElement(\"div\");\n    container.style.display = \"block\";\n    container.style.position = \"absolute\";\n    container.style.bottom = 0;\n    container.style.right = 0;\n    container.style.width = 0;\n    container.style.height = 0;\n    container.style.margin = 0;\n    container.style.padding = 0;\n    container.style.visibility = \"hidden\";\n    container.style.overflow = \"hidden\";\n    var space = document.createElement(\"span\");\n    space.style.fontSize = \"2000px\";\n    space.innerHTML = \"&nbsp;\";\n    container.appendChild(space);\n    el.appendChild(container);\n    var dims = space.getBoundingClientRect();\n    container.parentNode.removeChild(container);\n    var spaceRatio = dims.height / dims.width;\n    return h / spaceRatio;\n  }\n  /**\n   * Get a list of elements regardless of input\n   *\n   * @param {string|Node|Array-like} elements - The selector to query, one or more elements\n   * @return {Array<{Node}>}\n   */\n\n\n  function getElementsList(elements) {\n    if (!elements) {\n      return [];\n    } // is selector\n\n\n    if (typeof elements === \"string\") {\n      return document.querySelectorAll(elements);\n    } // is single element\n\n\n    if (elements.tagName && elements.querySelectorAll) {\n      return [elements];\n    }\n\n    return elements;\n  }\n  /**\n   *  When a browser has native support for the text-wrap property,\n   * the text balanceText plugin will let the browser handle it natively,\n   * otherwise it will apply its own text balancing code.\n   *\n   * @param {string|Node|Array-like} elements - the list of elements to balance\n   */\n\n\n  function balanceText(elements) {\n    forEach(getElementsList(elements), function (el) {\n      // In a lower level language, this algorithm takes time\n      // comparable to normal text layout other than the fact\n      // that we do two passes instead of one, so we should\n      // be able to do without this limit.\n      var maxTextWidth = 5000; // strip balance-text generated tags\n\n      removeTags(el); // save settings\n\n      var oldWS = el.style.whiteSpace;\n      var oldFloat = el.style.float;\n      var oldDisplay = el.style.display;\n      var oldPosition = el.style.position;\n      var oldLH = el.style.lineHeight; // remove line height before measuring container size\n\n      el.style.lineHeight = \"normal\";\n      var containerWidth = el.offsetWidth;\n      var containerHeight = el.offsetHeight; // temporary settings\n\n      el.style.whiteSpace = \"nowrap\";\n      el.style.float = \"none\";\n      el.style.display = \"inline\";\n      el.style.position = \"static\";\n      var nowrapWidth = el.offsetWidth;\n      var nowrapHeight = el.offsetHeight; // An estimate of the average line width reduction due\n      // to trimming trailing space that we expect over all\n      // lines other than the last.\n\n      var spaceWidth = oldWS === \"pre-wrap\" ? 0 : getSpaceWidth(el, nowrapHeight);\n\n      if (containerWidth > 0 && // prevent divide by zero\n      nowrapWidth > containerWidth && // text is more than 1 line\n      nowrapWidth < maxTextWidth) {\n        // text is less than arbitrary limit (make this a param?)\n        var remainingText = el.innerHTML;\n        var newText = \"\";\n        var lineText = \"\";\n        var shouldJustify = isJustified(el);\n        var totLines = Math.round(containerHeight / nowrapHeight);\n        var remLines = totLines;\n        var lineCharOffset = 0; // loop vars\n\n        var desiredWidth, guessIndex, le, ge, splitIndex, isHyphen, isSoftHyphen; // Determine where to break:\n\n        while (remLines > 1) {\n          // clear whitespace match cache for each line\n          breakMatches = null; // Must calc white-space:nowrap offsets before first call to findBreakOpportunity()\n\n          calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset);\n          desiredWidth = Math.round((nowrapWidth + spaceWidth) / remLines - spaceWidth); // Guessed char index\n\n          guessIndex = Math.round((remainingText.length + 1) / remLines) - 1;\n          le = new NextWS_params(); // Find a breaking space somewhere before (or equal to) desired width,\n          // not necessarily the closest to the desired width.\n\n          findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le); // Find first breaking char after (or equal to) desired width.\n\n          ge = new NextWS_params();\n          guessIndex = le.index;\n          findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, +1, guessIndex, ge); // Find first breaking char before (or equal to) desired width.\n\n          le.reset();\n          guessIndex = ge.index;\n          findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le); // Find closest string to desired length\n\n          if (le.index === 0) {\n            splitIndex = ge.index;\n          } else if (containerWidth < ge.width || le.index === ge.index) {\n            splitIndex = le.index;\n          } else {\n            splitIndex = Math.abs(desiredWidth - le.width) < Math.abs(ge.width - desiredWidth) ? le.index : ge.index;\n          } // Break string\n\n\n          lineText = remainingText.substr(0, splitIndex).replace(/\\s$/, \"\");\n          isSoftHyphen = Boolean(lineText.match(/\\u00ad$/));\n\n          if (isSoftHyphen) {\n            // Replace soft-hyphen causing break with explicit hyphen\n            lineText = lineText.replace(/\\u00ad$/, '<span data-owner=\"balance-text-softhyphen\">-</span>');\n          }\n\n          if (shouldJustify) {\n            newText += justify(el, lineText, containerWidth);\n          } else {\n            newText += lineText;\n            isHyphen = isSoftHyphen || Boolean(lineText.match(/(-|\\u2014|\\u2013)$/));\n            newText += isHyphen ? '<br data-owner=\"balance-text-hyphen\" />' : '<br data-owner=\"balance-text\" />';\n          }\n\n          remainingText = remainingText.substr(splitIndex);\n          lineCharOffset = splitIndex; // update counters\n\n          remLines--;\n          el.innerHTML = remainingText;\n          nowrapWidth = el.offsetWidth;\n        }\n\n        if (shouldJustify) {\n          el.innerHTML = newText + justify(el, remainingText, containerWidth);\n        } else {\n          el.innerHTML = newText + remainingText;\n        }\n      } // restore settings\n\n\n      el.style.whiteSpace = oldWS;\n      el.style.float = oldFloat;\n      el.style.display = oldDisplay;\n      el.style.position = oldPosition;\n      el.style.lineHeight = oldLH;\n    });\n  }\n  /**\n   * Call the balanceText plugin on elements that it's watching.\n   */\n\n\n  function updateWatched() {\n    var selectors = watching.sel.join(\",\");\n    var selectedElements = getElementsList(selectors);\n    var elements = Array.prototype.concat.apply(watching.el, selectedElements);\n    balanceText(elements);\n  }\n  /**\n   * Initialize the events for which to re-apply BalanceText.  They are:\n   * - Document ready\n   * - Document full load\n   * - Window resize\n   */\n\n\n  function initHandlers() {\n    if (handlersInitialized) {\n      return;\n    } // Apply on DOM ready\n\n\n    ready(updateWatched); // Reapply on full load\n\n    window.addEventListener(\"load\", updateWatched); // Reapply on resize\n\n    window.addEventListener(\"resize\", debounce(updateWatched));\n    handlersInitialized = true;\n  }\n  /**\n   * Apply the BalanceText routine on the document and watch the list\n   * of elements.  On window resize, re-apply BalanceText to the given elements\n   *\n   * @param {string|Node|Array-like} elements - the elements to watch after applying BalanceText\n   */\n\n\n  function balanceTextAndWatch(elements) {\n    if (typeof elements === \"string\") {\n      watching.sel.push(elements);\n    } else {\n      forEach(getElementsList(elements), function (el) {\n        watching.el.push(el);\n      });\n    }\n\n    initHandlers();\n    updateWatched();\n  }\n  /**\n   * Stop watching elements\n   *\n   * @param {string|Node|Array-like} elements\n   */\n\n\n  function unwatch(elements) {\n    if (typeof elements === \"string\") {\n      watching.sel = watching.sel.filter(function (el) {\n        return el !== elements;\n      });\n    } else {\n      elements = getElementsList(elements);\n      watching.el = watching.el.filter(function (el) {\n        return elements.indexOf(el) === -1;\n      });\n    }\n  }\n  /**\n   * Treat this app as a polyfill.  Watch for changes to the .balance-text selector\n   */\n\n\n  function polyfill() {\n    if (polyfilled) {\n      return;\n    }\n\n    watching.sel.push(\".balance-text\");\n    initHandlers();\n    polyfilled = true;\n  }\n  /**\n   * Public interface\n   *\n   * @param {string|Node|Array-like} elements - elements to balance\n   * @param {Object}                 options  - processing options\n   *  - {boolean} watch - watch elements for resize\n   */\n\n\n  function publicInterface(elements, options) {\n    if (!elements) {\n      // empty call means polyfill (watch for changes)\n      polyfill();\n    } else if (options && options.watch === true) {\n      balanceTextAndWatch(elements);\n    } else if (options && options.watch === false) {\n      unwatch(elements);\n    } else {\n      balanceText(elements);\n    }\n  }\n\n  publicInterface.updateWatched = updateWatched;\n\n  if (hasTextWrap()) {\n    noop.updateWatched = noop;\n    return noop;\n  }\n\n  return publicInterface;\n});","map":{"version":3,"sources":["/Users/robertpage/Documents/Programming/Projects/sarah_portfolio_site/Production/frontend/node_modules/balance-text/balancetext.js"],"names":["root","factory","define","amd","module","exports","balanceText","breakMatches","wsnwMatches","wsnwOffset","watching","sel","el","handlersInitialized","polyfilled","noop","forEach","elements","callback","Array","prototype","call","ready","fn","document","readyState","addEventListener","attachEvent","debounce","func","threshold","execAsap","args","timeout","obj","delayed","apply","clearTimeout","setTimeout","hasTextWrap","window","style","documentElement","textWrap","WebkitTextWrap","MozTextWrap","MsTextWrap","NextWS_params","reset","index","width","isWhiteSpaceNoWrap","some","range","start","end","recursiveCalcNoWrapOffsetsForLine","includeTag","nodeType","ELEMENT_NODE","getComputedStyle","whiteSpace","len","outerHTML","length","push","childNodes","child","innerHTML","COMMENT_NODE","PROCESSING_INSTRUCTION_NODE","calcNoWrapOffsetsForLine","oldWS","lineCharOffset","newMatches","match","removeTags","brs","querySelectorAll","br","spans","span","textNode","createTextNode","parentNode","insertBefore","removeChild","txt","textContent","isJustified","currentStyle","textAlign","justify","conWidth","trim","words","split","tmp","createElement","appendChild","size","offsetWidth","wordSpacing","Math","floor","setAttribute","div","isBreakChar","re","exec","indexOf","isBreakOpportunity","findBreakOpportunity","desWidth","dir","c","ret","w","substr","getSpaceWidth","h","container","display","position","bottom","right","height","margin","padding","visibility","overflow","space","fontSize","dims","getBoundingClientRect","spaceRatio","getElementsList","tagName","maxTextWidth","oldFloat","float","oldDisplay","oldPosition","oldLH","lineHeight","containerWidth","containerHeight","offsetHeight","nowrapWidth","nowrapHeight","spaceWidth","remainingText","newText","lineText","shouldJustify","totLines","round","remLines","desiredWidth","guessIndex","le","ge","splitIndex","isHyphen","isSoftHyphen","abs","replace","Boolean","updateWatched","selectors","join","selectedElements","concat","initHandlers","balanceTextAndWatch","unwatch","filter","polyfill","publicInterface","options","watch"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License. *\n */\n/**\n * balancetext.js\n *\n * Author: Randy Edmunds\n */\n\n/* global define, module */\n\n/*\n * Copyright (c) 2007-2009 unscriptable.com and John M. Hann\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the “Software”), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the name(s) of the above\n * copyright holders (unscriptable.com and John M. Hann) shall not be\n * used in advertising or otherwise to promote the sale, use or other\n * dealings in this Software without prior written authorization.\n *\n * http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/\n *\n * Tested to work on (lowest browser):\n * - Sarari 4\n * - Chrome 16\n * - Firefox 10\n * - IE 9\n * - Edge 13\n */\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory();\n    } else {\n        root.balanceText = factory();\n    }\n}(this, () => {\n    /**\n     * Line breaking global vars\n     */\n    let breakMatches, wsnwMatches, wsnwOffset;\n\n    /**\n     * Selectors and elements to watch;\n     * calling $.balanceText(elements) adds \"elements\" to this list.\n     */\n    const watching = {\n        sel: [], // default class to watch\n        el: [],\n    };\n\n    /**\n     * Have handlers been initialized?\n     */\n    let handlersInitialized = false;\n\n    /**\n     * Is this a polyfill?\n     */\n    let polyfilled = false;\n\n\n    /**\n     * Do nothing\n     */\n    function noop() { }\n\n    /**\n     * Loop that works with array-likes\n     * @param {Array-like} elements - List of elements to run a function on\n     * @param {Function}   callback - The function to call on each supplied element\n     */\n    function forEach(elements, callback) {\n        Array.prototype.forEach.call(elements, callback);\n    }\n\n    /**\n     * Polyfill for $(document).ready()\n     *\n     * @param {Function} fn - The function to execute when the document is ready\n     */\n    function ready(fn) {\n        if (document.readyState !== \"loading\") {\n            fn();\n        } else if (document.addEventListener) {\n            document.addEventListener(\"DOMContentLoaded\", fn);\n        } else {\n            document.attachEvent(\"onreadystatechange\", () => {\n                if (document.readyState !== \"loading\") {\n                    fn();\n                }\n            });\n        }\n    }\n\n    /**\n     * Debounces a function over a threshold\n     *\n     * @param {Function} func      - The function to debounce\n     * @param {number}   threshold - time in ms\n     * @param {boolean}  execAsap  - when true, execute immediately\n     * @param args\n     * @return {Function} Debounced function\n     */\n    function debounce(func, threshold, execAsap, ...args) {\n        let timeout;\n\n        return function () {\n            const obj = this;\n\n            function delayed() {\n                if (!execAsap) {\n                    func.apply(obj, args);\n                }\n                timeout = null;\n            }\n\n            if (timeout) {\n                clearTimeout(timeout);\n            } else if (execAsap) {\n                func.apply(obj, args);\n            }\n            timeout = setTimeout(delayed, threshold || 100);\n        };\n    }\n\n    /**\n     * Determine whether the document supports TextWrap\n     * @return {boolean}\n     */\n    function hasTextWrap() {\n        if (typeof window === \"undefined\") {\n            return false;\n        }\n        const { style } = document.documentElement;\n        return style.textWrap || style.WebkitTextWrap || style.MozTextWrap || style.MsTextWrap;\n    }\n\n    /**\n     * Object for tracking next whitespace params\n     */\n    // eslint-disable-next-line camelcase\n    function NextWS_params() {\n        this.reset();\n    }\n\n    NextWS_params.prototype.reset = function () {\n        this.index = 0;\n        this.width = 0;\n    };\n\n    /**\n     * Check if index is contained in previously calculated list of white-space:nowrap ranges\n     *\n     * @param {number} index - the index of the character to check\n     * @return {boolean}\n     */\n    function isWhiteSpaceNoWrap(index) {\n        // Is index inside 1 of the ranges?\n        // start and end are breakable, but not inside range\n        return wsnwMatches.some(range => (range.start < index && index < range.end));\n    }\n\n    /**\n     * Recursively calculate white-space:nowrap offsets for line.\n     *\n     * @param {Node}    el         - the element to act on\n     * @param {boolean} includeTag - include length of tag itself\n     */\n    function recursiveCalcNoWrapOffsetsForLine(el, includeTag) {\n        if (el.nodeType === el.ELEMENT_NODE) {\n            // Found an embedded tag\n            const style = window.getComputedStyle(el);\n            if (style.whiteSpace === \"nowrap\") {\n                // Tag with white-space:nowrap - add match, skip children\n                const len = el.outerHTML.length;\n                wsnwMatches.push({ start: wsnwOffset, end: wsnwOffset + len });\n                wsnwOffset += len;\n            } else {\n                // Tag without white-space:nowrap - recursively check children of tag\n                forEach(el.childNodes, (child) => {\n                    recursiveCalcNoWrapOffsetsForLine(child, true);\n                });\n                if (includeTag) {\n                    // Length of opening tag, attributes, and closing tag\n                    wsnwOffset += (el.outerHTML.length - el.innerHTML.length);\n                }\n            }\n        } else if (el.nodeType === el.COMMENT_NODE) {\n            wsnwOffset += el.length + 7; // delimiter: <!-- -->\n        } else if (el.nodeType === el.PROCESSING_INSTRUCTION_NODE) {\n            wsnwOffset += el.length + 2; // delimiter: < >\n        } else {\n            // Text node: add length\n            wsnwOffset += el.length;\n        }\n    }\n\n    /**\n     * Calculate white-space:nowrap offsets for line.\n     *\n     * @param {Node}    el             - the element to act on\n     * @param {string}  oldWS          - \"old\" whitespace setting for temporarily resetting\n     * @param {number}  lineCharOffset - char offset of current line from start of text\n     */\n    function calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset) {\n        // For first line (lineCharOffset === 0), calculate start and end offsets for each\n        // white-space:nowrap element in the line.\n        if (lineCharOffset === 0) {\n            // Reset whiteSpace setting when breakMatches is being calculated\n            // so white-space:nowrap can be detected in text\n            el.style.whiteSpace = oldWS;\n\n            wsnwOffset = 0;\n            wsnwMatches = [];\n            recursiveCalcNoWrapOffsetsForLine(el, false);\n\n            // Restore temporary whitespace setting to recalc width\n            el.style.whiteSpace = \"nowrap\";\n        } else {\n            // For all other lines, update the offsets for current line\n            // 1. Ignore matches less than offset\n            // 2. Subtract offset from remaining matches\n            const newMatches = [];\n            wsnwMatches.forEach((match) => {\n                if (match.start > lineCharOffset) {\n                    newMatches.push({ start: match.start - lineCharOffset, end: match.end - lineCharOffset });\n                }\n            });\n            wsnwMatches = newMatches;\n        }\n    }\n\n    /**\n     * Strip balance-text tags from an element inserted in previous run\n     *\n     * @param {Node} el - the element to act on\n     */\n    function removeTags(el) {\n        // Remove soft-hyphen breaks\n        let brs = el.querySelectorAll('br[data-owner=\"balance-text-hyphen\"]');\n        forEach(brs, (br) => {\n            br.outerHTML = \"\";\n        });\n\n        // Replace other breaks with whitespace\n        brs = el.querySelectorAll('br[data-owner=\"balance-text\"]');\n        forEach(brs, (br) => {\n            br.outerHTML = \" \";\n        });\n\n        // Restore hyphens inserted for soft-hyphens\n        let spans = el.querySelectorAll('span[data-owner=\"balance-text-softhyphen\"]');\n        if (spans.length > 0) {\n            forEach(spans, (span) => {\n                const textNode = document.createTextNode(\"\\u00ad\");\n                span.parentNode.insertBefore(textNode, span);\n                span.parentNode.removeChild(span);\n            });\n        }\n\n        // Remove spans inserted for justified text\n        spans = el.querySelectorAll('span[data-owner=\"balance-text-justify\"]');\n        if (spans.length > 0) {\n            let txt = \"\";\n            forEach(spans, (span) => {\n                txt += span.textContent;\n                span.parentNode.removeChild(span);\n            });\n            el.innerHTML = txt;\n        }\n    }\n\n    /**\n     * Checks to see if we should justify the balanced text with the\n     * element based on the textAlign property in the computed CSS\n     *\n     * @param {Node} el - element to check\n     * @return {boolean}\n     */\n    const isJustified = function (el) {\n        const style = el.currentStyle || window.getComputedStyle(el, null);\n        return (style.textAlign === \"justify\");\n    };\n\n    /**\n     * Add whitespace after words in text to justify the string to\n     * the specified size.\n     * @param {Node}    el       - the element to justify\n     * @param {string}  txt      - text string\n     * @param {number}  conWidth - container width\n     * @return {string} Justified text\n     */\n    function justify(el, txt, conWidth) {\n        txt = txt.trim();\n        const words = txt.split(\" \").length;\n        txt = `${txt} `;\n\n        // if we don't have at least 2 words, no need to justify.\n        if (words < 2) {\n            return txt;\n        }\n\n        // Find width of text in the DOM\n        const tmp = document.createElement(\"span\");\n        tmp.innerHTML = txt;\n        el.appendChild(tmp);\n        const size = tmp.offsetWidth;\n        tmp.parentNode.removeChild(tmp);\n\n        // Figure out our word spacing and return the element\n        const wordSpacing = Math.floor((conWidth - size) / (words - 1));\n        tmp.style.wordSpacing = `${wordSpacing}px`;\n        tmp.setAttribute(\"data-owner\", \"balance-text-justify\");\n\n        const div = document.createElement(\"div\");\n        div.appendChild(tmp);\n        return div.innerHTML;\n    }\n\n    /**\n     * Returns true iff char at index is a break char outside of HTML < > tags.\n     * Break char can be: whitespace (except non-breaking-space: u00a0),\n     * hypen, emdash (u2014), endash (u2013), or soft-hyphen (u00ad).\n     *\n     * @param {string} txt   - the text to check\n     * @param {number} index - the index of the character to check\n     * @return {boolean}\n     */\n    function isBreakChar(txt, index) {\n        const re = /([^\\S\\u00a0]|-|\\u2014|\\u2013|\\u00ad)(?![^<]*>)/g;\n        let match;\n\n        if (!breakMatches) {\n            // Only calc break matches once per line\n            breakMatches = [];\n            match = re.exec(txt);\n            while (match !== null) {\n                if (!isWhiteSpaceNoWrap(match.index)) {\n                    breakMatches.push(match.index);\n                }\n                match = re.exec(txt);\n            }\n        }\n\n        return breakMatches.indexOf(index) !== -1;\n    }\n\n    /**\n     * In the current implementation, an index is a break\n     * opportunity in txt iff it is:\n     * - 0 or txt.length\n     * - index of a non-whitespace char immediately preceded by a\n     *   whitespace, hyphen, soft-hyphen, em-dash, or en-dash char.\n     *\n     * Thus, it doesn't honour \"white-space\" or any other Unicode\n     * line-breaking classes.)\n     *\n     * @precondition 0 <= index && index <= txt.length\n     *\n     * @param {string} txt   - the text to check\n     * @param {number} index - the index to check\n     * @return {boolean}\n     */\n    function isBreakOpportunity(txt, index) {\n        return ((index === 0) || (index === txt.length) ||\n                (isBreakChar(txt, index - 1) && !isBreakChar(txt, index)));\n    }\n\n    /**\n     * Finds the first break opportunity (@see isBreakOpportunity)\n     * in txt that's both after-or-equal-to index c in the direction dir\n     * and resulting in line width equal to or past clamp(desWidth,\n     * 0, conWidth) in direction dir.  Sets ret.index and ret.width\n     * to the corresponding index and line width (from the start of\n     * txt to ret.index).\n     *\n     * @param {Node}    el       - element\n     * @param {string}  txt      - text string\n     * @param {number}  conWidth - container width\n     * @param {number}  desWidth - desired width\n     * @param {number}  dir      - direction (-1 or +1)\n     * @param {number}  c        - char index (0 <= c && c <= txt.length)\n     * @param {Object}  ret      - return {index: {number}, width: {number}} of previous/next break\n     */\n    function findBreakOpportunity(el, txt, conWidth, desWidth, dir, c, ret) {\n        let w;\n\n        if (txt && typeof txt === \"string\") {\n            for (;;) {\n                while (!isBreakOpportunity(txt, c)) {\n                    c += dir;\n                }\n\n                el.innerHTML = txt.substr(0, c);\n                w = el.offsetWidth;\n\n                if (dir < 0) {\n                    if ((w <= desWidth) || (w <= 0) || (c === 0)) {\n                        break;\n                    }\n                } else if ((desWidth <= w) || (conWidth <= w) || (c === txt.length)) {\n                    break;\n                }\n\n                c += dir;\n            }\n        }\n        ret.index = c;\n        ret.width = w;\n    }\n\n    /**\n     * Detects the width of a non-breaking space character, given the height of\n     * the element with no-wrap applied.\n     *\n     * @param {Node}   el - element\n     * @param {number} h  - height\n     * @return {number}\n     */\n    function getSpaceWidth(el, h) {\n        const container = document.createElement(\"div\");\n\n        container.style.display = \"block\";\n        container.style.position = \"absolute\";\n        container.style.bottom = 0;\n        container.style.right = 0;\n        container.style.width = 0;\n        container.style.height = 0;\n        container.style.margin = 0;\n        container.style.padding = 0;\n        container.style.visibility = \"hidden\";\n        container.style.overflow = \"hidden\";\n\n        const space = document.createElement(\"span\");\n\n        space.style.fontSize = \"2000px\";\n        space.innerHTML = \"&nbsp;\";\n\n        container.appendChild(space);\n\n        el.appendChild(container);\n\n        const dims = space.getBoundingClientRect();\n        container.parentNode.removeChild(container);\n\n        const spaceRatio = dims.height / dims.width;\n\n        return (h / spaceRatio);\n    }\n\n    /**\n     * Get a list of elements regardless of input\n     *\n     * @param {string|Node|Array-like} elements - The selector to query, one or more elements\n     * @return {Array<{Node}>}\n     */\n    function getElementsList(elements) {\n        if (!elements) {\n            return [];\n        }\n\n        // is selector\n        if (typeof elements === \"string\") {\n            return document.querySelectorAll(elements);\n        }\n\n        // is single element\n        if (elements.tagName && elements.querySelectorAll) {\n            return [elements];\n        }\n\n        return elements;\n    }\n\n    /**\n     *  When a browser has native support for the text-wrap property,\n     * the text balanceText plugin will let the browser handle it natively,\n     * otherwise it will apply its own text balancing code.\n     *\n     * @param {string|Node|Array-like} elements - the list of elements to balance\n     */\n    function balanceText(elements) {\n        forEach(getElementsList(elements), (el) => {\n            // In a lower level language, this algorithm takes time\n            // comparable to normal text layout other than the fact\n            // that we do two passes instead of one, so we should\n            // be able to do without this limit.\n            const maxTextWidth = 5000;\n\n            // strip balance-text generated tags\n            removeTags(el);\n\n            // save settings\n            const oldWS = el.style.whiteSpace;\n            const oldFloat = el.style.float;\n            const oldDisplay = el.style.display;\n            const oldPosition = el.style.position;\n            const oldLH = el.style.lineHeight;\n\n            // remove line height before measuring container size\n            el.style.lineHeight = \"normal\";\n\n            const containerWidth = el.offsetWidth;\n            const containerHeight = el.offsetHeight;\n\n            // temporary settings\n            el.style.whiteSpace = \"nowrap\";\n            el.style.float = \"none\";\n            el.style.display = \"inline\";\n            el.style.position = \"static\";\n\n            let nowrapWidth = el.offsetWidth;\n            const nowrapHeight = el.offsetHeight;\n\n            // An estimate of the average line width reduction due\n            // to trimming trailing space that we expect over all\n            // lines other than the last.\n            const spaceWidth = ((oldWS === \"pre-wrap\") ? 0 : getSpaceWidth(el, nowrapHeight));\n\n            if (containerWidth > 0 &&               // prevent divide by zero\n                    nowrapWidth > containerWidth && // text is more than 1 line\n                    nowrapWidth < maxTextWidth) {   // text is less than arbitrary limit (make this a param?)\n                let remainingText = el.innerHTML;\n                let newText = \"\";\n                let lineText = \"\";\n                const shouldJustify = isJustified(el);\n                const totLines = Math.round(containerHeight / nowrapHeight);\n                let remLines = totLines;\n                let lineCharOffset = 0;\n\n                // loop vars\n                let desiredWidth, guessIndex, le, ge, splitIndex, isHyphen, isSoftHyphen;\n\n                // Determine where to break:\n                while (remLines > 1) {\n                    // clear whitespace match cache for each line\n                    breakMatches = null;\n\n                    // Must calc white-space:nowrap offsets before first call to findBreakOpportunity()\n                    calcNoWrapOffsetsForLine(el, oldWS, lineCharOffset);\n\n                    desiredWidth = Math.round((nowrapWidth + spaceWidth) / remLines - spaceWidth);\n\n                    // Guessed char index\n                    guessIndex = Math.round((remainingText.length + 1) / remLines) - 1;\n\n                    le = new NextWS_params();\n\n                    // Find a breaking space somewhere before (or equal to) desired width,\n                    // not necessarily the closest to the desired width.\n                    findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le);\n\n                    // Find first breaking char after (or equal to) desired width.\n                    ge = new NextWS_params();\n                    guessIndex = le.index;\n                    findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, +1, guessIndex, ge);\n\n                    // Find first breaking char before (or equal to) desired width.\n                    le.reset();\n                    guessIndex = ge.index;\n                    findBreakOpportunity(el, remainingText, containerWidth, desiredWidth, -1, guessIndex, le);\n\n                    // Find closest string to desired length\n                    if (le.index === 0) {\n                        splitIndex = ge.index;\n                    } else if ((containerWidth < ge.width) || (le.index === ge.index)) {\n                        splitIndex = le.index;\n                    } else {\n                        splitIndex = ((Math.abs(desiredWidth - le.width) < Math.abs(ge.width - desiredWidth))\n                            ? le.index\n                            : ge.index);\n                    }\n\n                    // Break string\n                    lineText = remainingText.substr(0, splitIndex).replace(/\\s$/, \"\");\n\n                    isSoftHyphen = Boolean(lineText.match(/\\u00ad$/));\n                    if (isSoftHyphen) {\n                        // Replace soft-hyphen causing break with explicit hyphen\n                        lineText = lineText.replace(/\\u00ad$/, '<span data-owner=\"balance-text-softhyphen\">-</span>');\n                    }\n\n                    if (shouldJustify) {\n                        newText += justify(el, lineText, containerWidth);\n                    } else {\n                        newText += lineText;\n                        isHyphen = isSoftHyphen || Boolean(lineText.match(/(-|\\u2014|\\u2013)$/));\n                        newText += isHyphen ? '<br data-owner=\"balance-text-hyphen\" />'\n                            : '<br data-owner=\"balance-text\" />';\n                    }\n                    remainingText = remainingText.substr(splitIndex);\n                    lineCharOffset = splitIndex;\n\n                    // update counters\n                    remLines--;\n                    el.innerHTML = remainingText;\n                    nowrapWidth = el.offsetWidth;\n                }\n\n                if (shouldJustify) {\n                    el.innerHTML = newText + justify(el, remainingText, containerWidth);\n                } else {\n                    el.innerHTML = newText + remainingText;\n                }\n            }\n\n            // restore settings\n            el.style.whiteSpace = oldWS;\n            el.style.float = oldFloat;\n            el.style.display = oldDisplay;\n            el.style.position = oldPosition;\n            el.style.lineHeight = oldLH;\n        });\n    }\n\n    /**\n     * Call the balanceText plugin on elements that it's watching.\n     */\n    function updateWatched() {\n        const selectors = watching.sel.join(\",\");\n        const selectedElements = getElementsList(selectors);\n        const elements = Array.prototype.concat.apply(watching.el, selectedElements);\n        balanceText(elements);\n    }\n\n    /**\n     * Initialize the events for which to re-apply BalanceText.  They are:\n     * - Document ready\n     * - Document full load\n     * - Window resize\n     */\n    function initHandlers() {\n        if (handlersInitialized) {\n            return;\n        }\n\n        // Apply on DOM ready\n        ready(updateWatched);\n\n        // Reapply on full load\n        window.addEventListener(\"load\", updateWatched);\n\n        // Reapply on resize\n        window.addEventListener(\"resize\", debounce(updateWatched));\n\n        handlersInitialized = true;\n    }\n\n    /**\n     * Apply the BalanceText routine on the document and watch the list\n     * of elements.  On window resize, re-apply BalanceText to the given elements\n     *\n     * @param {string|Node|Array-like} elements - the elements to watch after applying BalanceText\n     */\n    function balanceTextAndWatch(elements) {\n        if (typeof elements === \"string\") {\n            watching.sel.push(elements);\n        } else {\n            forEach(getElementsList(elements), (el) => {\n                watching.el.push(el);\n            });\n        }\n\n        initHandlers();\n        updateWatched();\n    }\n\n    /**\n     * Stop watching elements\n     *\n     * @param {string|Node|Array-like} elements\n     */\n    function unwatch(elements) {\n        if (typeof elements === \"string\") {\n            watching.sel = watching.sel.filter(el => el !== elements);\n        } else {\n            elements = getElementsList(elements);\n            watching.el = watching.el.filter(el => elements.indexOf(el) === -1);\n        }\n    }\n\n    /**\n     * Treat this app as a polyfill.  Watch for changes to the .balance-text selector\n     */\n    function polyfill() {\n        if (polyfilled) {\n            return;\n        }\n\n        watching.sel.push(\".balance-text\");\n        initHandlers();\n        polyfilled = true;\n    }\n\n    /**\n     * Public interface\n     *\n     * @param {string|Node|Array-like} elements - elements to balance\n     * @param {Object}                 options  - processing options\n     *  - {boolean} watch - watch elements for resize\n     */\n    function publicInterface(elements, options) {\n        if (!elements) {\n            // empty call means polyfill (watch for changes)\n            polyfill();\n        } else if (options && options.watch === true) {\n            balanceTextAndWatch(elements);\n        } else if (options && options.watch === false) {\n            unwatch(elements);\n        } else {\n            balanceText(elements);\n        }\n    }\n\n    publicInterface.updateWatched = updateWatched;\n\n    if (hasTextWrap()) {\n        noop.updateWatched = noop;\n        return noop;\n    }\n    return publicInterface;\n}));\n"]},"metadata":{},"sourceType":"script"}